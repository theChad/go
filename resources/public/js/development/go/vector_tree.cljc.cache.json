["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$go.vector-tree","~:imports",null,"~:requires",null,"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$get-branch-node",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/home/chad/Code/clojure/go/src/go/vector_tree.cljc","~:line",35,"~:column",7,"~:end-line",35,"~:end-column",22,"~:arglists",["~#list",["~$quote",["^G",[["~$branch"]]]]],"~:doc","Return the index of the last common element in the branch."],"^7","~$go.vector-tree/get-branch-node","^A","src/go/vector_tree.cljc","^E",22,"~:method-params",["^G",[["^I"]]],"~:protocol-impl",null,"~:arglists-meta",["^G",[null,null]],"^C",1,"~:variadic?",false,"^B",35,"~:ret-tag","~$number","^D",35,"~:max-fixed-arity",1,"~:fn-var",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Return the index of the last common element in the branch."],"~$end-of-branch",["^ ","^?",null,"^@",["^ ","^A","/home/chad/Code/clojure/go/src/go/vector_tree.cljc","^B",23,"^C",7,"^D",23,"^E",20,"^F",["^G",["^H",["^G",[["~$tree","~$position"]]]]],"^J","Return a position pointing to the end of the current branch.\n   E.g. If the current branch has length 5, [34 23 3] -> [34 23 5]."],"^7","~$go.vector-tree/end-of-branch","^A","src/go/vector_tree.cljc","^E",20,"^L",["^G",[["^U","^V"]]],"^M",null,"^N",["^G",[null,null]],"^C",1,"^O",false,"^B",23,"^P","~$clj","^D",23,"^R",2,"^S",true,"^F",["^G",["^H",["^G",[["^U","^V"]]]]],"^J","Return a position pointing to the end of the current branch.\n   E.g. If the current branch has length 5, [34 23 3] -> [34 23 5]."],"~$tree-parallel-search",["^ ","^?",null,"^@",["^ ","^A","/home/chad/Code/clojure/go/src/go/vector_tree.cljc","^B",124,"^C",7,"^D",124,"^E",27,"^F",["^G",["^H",["^G",[["^U","^V","~$item","~$item-eq-fn"],["^U","^V","^Z"]]]]],"^J","Search for item in same position in all parallel branches.\n   Return first occurence of item.\n   item-eq-fn [item tree-node] should compare the equality of the item searched for\n   and the elements of the tree.","~:top-fn",["^ ","^O",false,"~:fixed-arity",4,"^R",4,"^L",["^G",[["^U","^V","^Z","^["],["^U","^V","^Z"]]],"^F",["^G",[["^U","^V","^Z","^["],["^U","^V","^Z"]]],"^N",["^G",[null,null]]]],"^7","~$go.vector-tree/tree-parallel-search","^A","src/go/vector_tree.cljc","^E",27,"^10",["^ ","^O",false,"^11",4,"^R",4,"^L",["^G",[["^U","^V","^Z","^["],["^U","^V","^Z"]]],"^F",["^G",[["^U","^V","^Z","^["],["^U","^V","^Z"]]],"^N",["^G",[null,null]]],"^L",["^G",[["^U","^V","^Z","^["],["^U","^V","^Z"]]],"^M",null,"^11",4,"^N",["^G",[null,null]],"^C",1,"^O",false,"~:methods",[["^ ","^11",4,"^O",false,"~:tag",["^6",[null,"~$clj-nil"]]],["^ ","^11",3,"^O",false,"^14",["^6",[null,"^15"]]]],"^B",124,"^D",124,"^R",4,"^S",true,"^F",["^G",[["^U","^V","^Z","^["],["^U","^V","^Z"]]],"^J","Search for item in same position in all parallel branches.\n   Return first occurence of item.\n   item-eq-fn [item tree-node] should compare the equality of the item searched for\n   and the elements of the tree."],"~$tree-contains?",["^ ","^?",null,"^@",["^ ","^A","/home/chad/Code/clojure/go/src/go/vector_tree.cljc","^B",95,"^C",7,"^D",95,"^E",21,"^F",["^G",["^H",["^G",[["^U","^V"]]]]],"^J","True if the tree contains an element at position.\n   Tree is a vector-based tree, position is a get-in type vector."],"^7","~$go.vector-tree/tree-contains?","^A","src/go/vector_tree.cljc","^E",21,"^L",["^G",[["^U","^V"]]],"^M",null,"^N",["^G",[null,null]],"^C",1,"^O",false,"^B",95,"^P",["^6",["~$boolean","~$any"]],"^D",95,"^R",2,"^S",true,"^F",["^G",["^H",["^G",[["^U","^V"]]]]],"^J","True if the tree contains an element at position.\n   Tree is a vector-based tree, position is a get-in type vector."],"~$current-branch",["^ ","^?",null,"^@",["^ ","^A","/home/chad/Code/clojure/go/src/go/vector_tree.cljc","^B",15,"^C",7,"^D",15,"^E",21,"^F",["^G",["^H",["^G",[["^U","^V"]]]]],"^J","Return the branch containing position, starting after previous\n  branch point."],"^7","~$go.vector-tree/current-branch","^A","src/go/vector_tree.cljc","^E",21,"^L",["^G",[["^U","^V"]]],"^M",null,"^N",["^G",[null,null]],"^C",1,"^O",false,"^B",15,"^P",["^6",[null,"^19"]],"^D",15,"^R",2,"^S",true,"^F",["^G",["^H",["^G",[["^U","^V"]]]]],"^J","Return the branch containing position, starting after previous\n  branch point."],"~$in-same-branch?",["^ ","^?",null,"^@",["^ ","^A","/home/chad/Code/clojure/go/src/go/vector_tree.cljc","^B",89,"^C",7,"^D",89,"^E",22,"^F",["^G",["^H",["^G",[["~$pos1","~$pos2"]]]]],"^J","True if two positions are in the same sub-branch.\n   One being in a child branch of the other doesn't count."],"^7","~$go.vector-tree/in-same-branch?","^A","src/go/vector_tree.cljc","^E",22,"^L",["^G",[["^1=","^1>"]]],"^M",null,"^N",["^G",[null,null]],"^C",1,"^O",false,"^B",89,"^P","^18","^D",89,"^R",2,"^S",true,"^F",["^G",["^H",["^G",[["^1=","^1>"]]]]],"^J","True if two positions are in the same sub-branch.\n   One being in a child branch of the other doesn't count."],"~$last-common-branch-element?",["^ ","^?",null,"^@",["^ ","^A","/home/chad/Code/clojure/go/src/go/vector_tree.cljc","^B",74,"^C",7,"^D",74,"^E",34,"^F",["^G",["^H",["^G",[["~$index","~$v"]]]]],"^J","True if the index is the last element, or if the next element is a vector..\n   E.g. with index 3, [0 1 2 3 [4 5] [6 7]] is true."],"^7","~$go.vector-tree/last-common-branch-element?","^A","src/go/vector_tree.cljc","^E",34,"^L",["^G",[["^1A","~$v"]]],"^M",null,"^N",["^G",[null,null]],"^C",1,"^O",false,"^B",74,"^P","^18","^D",74,"^R",2,"^S",true,"^F",["^G",["^H",["^G",[["^1A","~$v"]]]]],"^J","True if the index is the last element, or if the next element is a vector..\n   E.g. with index 3, [0 1 2 3 [4 5] [6 7]] is true."],"~$last-index-in-vector?",["^ ","^?",null,"^@",["^ ","^A","/home/chad/Code/clojure/go/src/go/vector_tree.cljc","^B",69,"^C",7,"^D",69,"^E",28,"^F",["^G",["^H",["^G",[["^1A","~$vect"]]]]],"^J","True if the index represents the last position in the vector"],"^7","~$go.vector-tree/last-index-in-vector?","^A","src/go/vector_tree.cljc","^E",28,"^L",["^G",[["^1A","^1D"]]],"^M",null,"^N",["^G",[null,null]],"^C",1,"^O",false,"^B",69,"^P","^18","^D",69,"^R",2,"^S",true,"^F",["^G",["^H",["^G",[["^1A","^1D"]]]]],"^J","True if the index represents the last position in the vector"],"~$next-position",["^ ","^?",null,"^@",["^ ","^A","/home/chad/Code/clojure/go/src/go/vector_tree.cljc","^B",54,"^C",7,"^D",54,"^E",20,"^F",["^G",["^H",["^G",[["^U","^V"]]]]],"^J","Get the next position, going down the tree.\n  If position is at a branch point, go into the first created child branch."],"^7","~$go.vector-tree/next-position","^A","src/go/vector_tree.cljc","^E",20,"^L",["^G",[["^U","^V"]]],"^M",null,"^N",["^G",[null,null]],"^C",1,"^O",false,"^B",54,"^P",["^6",[null,"^X","^19"]],"^D",54,"^R",2,"^S",true,"^F",["^G",["^H",["^G",[["^U","^V"]]]]],"^J","Get the next position, going down the tree.\n  If position is at a branch point, go into the first created child branch."],"~$previous-position",["^ ","^?",null,"^@",["^ ","^A","/home/chad/Code/clojure/go/src/go/vector_tree.cljc","^B",44,"^C",7,"^D",44,"^E",24,"^F",["^G",["^H",["^G",[["^U","^V"]]]]],"^J","Get the previous position going up the tree."],"^7","~$go.vector-tree/previous-position","^A","src/go/vector_tree.cljc","^E",24,"^L",["^G",[["^U","^V"]]],"^M",null,"^N",["^G",[null,null]],"^C",1,"^O",false,"^B",44,"^P",["^6",["^X","~$cljs.core/IVector","^19"]],"^D",44,"^R",2,"^S",true,"^F",["^G",["^H",["^G",[["^U","^V"]]]]],"^J","Get the previous position going up the tree."],"~$position-up-parallel-branch",["^ ","^?",null,"^@",["^ ","^A","/home/chad/Code/clojure/go/src/go/vector_tree.cljc","^B",114,"^C",7,"^D",114,"^E",34,"^F",["^G",["^H",["^G",[["^U","^V"]]]]],"^J","Position of the next sibling branch."],"^7","~$go.vector-tree/position-up-parallel-branch","^A","src/go/vector_tree.cljc","^E",34,"^L",["^G",[["^U","^V"]]],"^M",null,"^N",["^G",[null,null]],"^C",1,"^O",false,"^B",114,"^P",["^6",[null,"^X","^19"]],"^D",114,"^R",2,"^S",true,"^F",["^G",["^H",["^G",[["^U","^V"]]]]],"^J","Position of the next sibling branch."],"~$branched-vector",["^ ","^?",null,"^@",["^ ","^A","/home/chad/Code/clojure/go/src/go/vector_tree.cljc","^B",81,"^C",7,"^D",81,"^E",22,"^F",["^G",["^H",["^G",[["~$enclosing-vector","^V"]]]]],"^J","The enclosing vector of the new branched vector.\n   Position here should just be a scalar.\n   Takes [1 2 3 4 5] with position 1 to [1 2 [3 4 5]]."],"^7","~$go.vector-tree/branched-vector","^A","src/go/vector_tree.cljc","^E",22,"^L",["^G",[["^1N","^V"]]],"^M",null,"^N",["^G",[null,null]],"^C",1,"^O",false,"^B",81,"^P","^X","^D",81,"^R",2,"^S",true,"^F",["^G",["^H",["^G",[["^1N","^V"]]]]],"^J","The enclosing vector of the new branched vector.\n   Position here should just be a scalar.\n   Takes [1 2 3 4 5] with position 1 to [1 2 [3 4 5]]."],"~$branch-point?",["^ ","^?",null,"^@",["^ ","^A","/home/chad/Code/clojure/go/src/go/vector_tree.cljc","^B",29,"^C",7,"^D",29,"^E",20,"^F",["^G",["^H",["^G",[["^U","^V"]]]]],"^J","True if the given position is a branch point"],"^7","~$go.vector-tree/branch-point?","^A","src/go/vector_tree.cljc","^E",20,"^L",["^G",[["^U","^V"]]],"^M",null,"^N",["^G",[null,null]],"^C",1,"^O",false,"^B",29,"^P","^18","^D",29,"^R",2,"^S",true,"^F",["^G",["^H",["^G",[["^U","^V"]]]]],"^J","True if the given position is a branch point"],"~$position-down-parallel-branch",["^ ","^?",null,"^@",["^ ","^A","/home/chad/Code/clojure/go/src/go/vector_tree.cljc","^B",104,"^C",7,"^D",104,"^E",36,"^F",["^G",["^H",["^G",[["^U","^V"]]]]],"^J","Position of the next sibling branch."],"^7","~$go.vector-tree/position-down-parallel-branch","^A","src/go/vector_tree.cljc","^E",36,"^L",["^G",[["^U","^V"]]],"^M",null,"^N",["^G",[null,null]],"^C",1,"^O",false,"^B",104,"^P",["^6",[null,"^X","^19"]],"^D",104,"^R",2,"^S",true,"^F",["^G",["^H",["^G",[["^U","^V"]]]]],"^J","Position of the next sibling branch."]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^6",["~:else"]],"~:order",["^1X"]],"^J",null]