["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$go.game-state","~:imports",null,"~:requires",["^ ","~$tree","~$go.vector-tree","^<","^<"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$get-move-at-position",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/home/chad/Code/clojure/go/src/go/game_state.cljc","~:line",51,"~:column",7,"~:end-line",51,"~:end-column",27,"~:arglists",["~#list",["~$quote",["^I",[["~$game-state","~$position"]]]]],"~:doc","Return the last move at a specific position in history."],"^7","~$go.game-state/get-move-at-position","^C","src/go/game_state.cljc","^G",27,"~:method-params",["^I",[["^K","^L"]]],"~:protocol-impl",null,"~:arglists-meta",["^I",[null,null]],"^E",1,"~:variadic?",false,"^D",51,"~:ret-tag","~$any","^F",51,"~:max-fixed-arity",2,"~:fn-var",true,"^H",["^I",["^J",["^I",[["^K","^L"]]]]],"^M","Return the last move at a specific position in history."],"~$end-of-branch",["^ ","^A",null,"^B",["^ ","^C","/home/chad/Code/clojure/go/src/go/game_state.cljc","^D",23,"^E",7,"^F",23,"^G",20,"^H",["^I",["^J",["^I",[["^K"]]]]],"^M","Return a position pointing to the end of the current branch.\n   E.g. If the current branch has length 5, [34 23 3] -> [34 23 5]."],"^7","~$go.game-state/end-of-branch","^C","src/go/game_state.cljc","^G",20,"^O",["^I",[["^K"]]],"^P",null,"^Q",["^I",[null,null]],"^E",1,"^R",false,"^D",23,"^S","~$clj","^F",23,"^U",1,"^V",true,"^H",["^I",["^J",["^I",[["^K"]]]]],"^M","Return a position pointing to the end of the current branch.\n   E.g. If the current branch has length 5, [34 23 3] -> [34 23 5]."],"~$add-move",["^ ","^A",null,"^B",["^ ","^C","/home/chad/Code/clojure/go/src/go/game_state.cljc","^D",158,"^E",7,"^F",158,"^G",15,"^H",["^I",["^J",["^I",[["^K","~$move","~$board"]]]]],"^M","Add a new move to the game state history."],"^7","~$go.game-state/add-move","^C","src/go/game_state.cljc","^G",15,"^O",["^I",[["^K","^[","^10"]]],"^P",null,"^Q",["^I",[null,null]],"^E",1,"^R",false,"^D",158,"^S",["^6",["^Y","^T"]],"^F",158,"^U",3,"^V",true,"^H",["^I",["^J",["^I",[["^K","^[","^10"]]]]],"^M","Add a new move to the game state history."],"~$matches-move?",["^ ","^A",null,"^B",["^ ","^C","/home/chad/Code/clojure/go/src/go/game_state.cljc","^D",56,"^E",7,"^F",56,"^G",20,"^H",["^I",["^J",["^I",[["^[","~$board-state"]]]]],"^M","Compares the move from a board state to the given move."],"^7","~$go.game-state/matches-move?","^C","src/go/game_state.cljc","^G",20,"^O",["^I",[["^[","^13"]]],"^P",null,"^Q",["^I",[null,null]],"^E",1,"^R",false,"^D",56,"^S","~$boolean","^F",56,"^U",2,"^V",true,"^H",["^I",["^J",["^I",[["^[","^13"]]]]],"^M","Compares the move from a board state to the given move."],"~$get-state-at-position",["^ ","^A",null,"^B",["^ ","^C","/home/chad/Code/clojure/go/src/go/game_state.cljc","^D",36,"^E",7,"^F",36,"^G",28,"^H",["^I",["^J",["^I",[["^K","^L"]]]]],"^M","Return the state or branch at a supplied position."],"^7","~$go.game-state/get-state-at-position","^C","src/go/game_state.cljc","^G",28,"^O",["^I",[["^K","^L"]]],"^P",null,"^Q",["^I",[null,null]],"^E",1,"^R",false,"^D",36,"^S",["^6",[null,"^T"]],"^F",36,"^U",2,"^V",true,"^H",["^I",["^J",["^I",[["^K","^L"]]]]],"^M","Return the state or branch at a supplied position."],"~$get-current-state",["^ ","^A",null,"^B",["^ ","^C","/home/chad/Code/clojure/go/src/go/game_state.cljc","^D",30,"^E",7,"^F",30,"^G",24,"^H",["^I",["^J",["^I",[["^K"]]]]],"^M","Return the current state from the game history."],"^7","~$go.game-state/get-current-state","^C","src/go/game_state.cljc","^G",24,"^O",["^I",[["^K"]]],"^P",null,"^Q",["^I",[null,null]],"^E",1,"^R",false,"^D",30,"^S",["^6",[null,"^T"]],"^F",30,"^U",1,"^V",true,"^H",["^I",["^J",["^I",[["^K"]]]]],"^M","Return the current state from the game history."],"~$create-game-state",["^ ","^A",null,"^B",["^ ","^C","/home/chad/Code/clojure/go/src/go/game_state.cljc","^D",71,"^E",7,"^F",71,"^G",24,"^H",["^I",["^J",["^I",[["~$size"],[]]]]],"^M","Create an empty game-state.","~:top-fn",["^ ","^R",false,"~:fixed-arity",1,"^U",1,"^O",["^I",[["^1;"],[]]],"^H",["^I",[["^1;"],[]]],"^Q",["^I",[null,null]]]],"^7","~$go.game-state/create-game-state","^C","src/go/game_state.cljc","^G",24,"^1<",["^ ","^R",false,"^1=",1,"^U",1,"^O",["^I",[["^1;"],[]]],"^H",["^I",[["^1;"],[]]],"^Q",["^I",[null,null]]],"^O",["^I",[["^1;"],[]]],"^P",null,"^1=",1,"^Q",["^I",[null,null]],"^E",1,"^R",false,"~:methods",[["^ ","^1=",1,"^R",false,"~:tag","~$cljs.core/IMap"],["^ ","^1=",0,"^R",false,"^1@","^1A"]],"^D",71,"^F",71,"^U",1,"^V",true,"^H",["^I",[["^1;"],[]]],"^M","Create an empty game-state."],"~$move-up-parallel-branch",["^ ","^A",null,"^B",["^ ","^C","/home/chad/Code/clojure/go/src/go/game_state.cljc","^D",135,"^E",7,"^F",135,"^G",30,"^H",["^I",["^J",["^I",[["^K"]]]]],"^M","Move down to the next sibling branch."],"^7","~$go.game-state/move-up-parallel-branch","^C","src/go/game_state.cljc","^G",30,"^O",["^I",[["^K"]]],"^P",null,"^Q",["^I",[null,null]],"^E",1,"^R",false,"^D",135,"^S",["^6",["^Y","^T"]],"^F",135,"^U",1,"^V",true,"^H",["^I",["^J",["^I",[["^K"]]]]],"^M","Move down to the next sibling branch."],"~$move-to-next-state",["^ ","^A",null,"^B",["^ ","^C","/home/chad/Code/clojure/go/src/go/game_state.cljc","^D",81,"^E",7,"^F",81,"^G",25,"^H",["^I",["^J",["^I",[["^K"]]]]],"^M","Move the position to the next state in the branch, or hold here if final."],"^7","~$go.game-state/move-to-next-state","^C","src/go/game_state.cljc","^G",25,"^O",["^I",[["^K"]]],"^P",null,"^Q",["^I",[null,null]],"^E",1,"^R",false,"^D",81,"^S",["^6",["^Y","^T"]],"^F",81,"^U",1,"^V",true,"^H",["^I",["^J",["^I",[["^K"]]]]],"^M","Move the position to the next state in the branch, or hold here if final."],"~$make-branch",["^ ","^A",null,"^B",["^ ","^C","/home/chad/Code/clojure/go/src/go/game_state.cljc","^D",91,"^E",7,"^F",91,"^G",18,"^H",["^I",["^J",["^I",[["^K"]]]]],"^M","Create a branch point at the current location in the game state history.\n   Only create the branch if the element pointed to by (:position game-state) is not\n   the last element of its branch. Create an empty branch and point position to it.\n   Note: the position returned from make-branch will always be right after\n   the last element, so settable but not gettable."],"^7","~$go.game-state/make-branch","^C","src/go/game_state.cljc","^G",18,"^O",["^I",[["^K"]]],"^P",null,"^Q",["^I",[null,null]],"^E",1,"^R",false,"^D",91,"^S",["^6",["^Y","^T"]],"^F",91,"^U",1,"^V",true,"^H",["^I",["^J",["^I",[["^K"]]]]],"^M","Create a branch point at the current location in the game state history.\n   Only create the branch if the element pointed to by (:position game-state) is not\n   the last element of its branch. Create an empty branch and point position to it.\n   Note: the position returned from make-branch will always be right after\n   the last element, so settable but not gettable."],"~$move-to-previous-state",["^ ","^A",null,"^B",["^ ","^C","/home/chad/Code/clojure/go/src/go/game_state.cljc","^D",61,"^E",7,"^F",61,"^G",29,"^H",["^I",["^J",["^I",[["^K"]]]]],"^M","Get the previous state along this branch."],"^7","~$go.game-state/move-to-previous-state","^C","src/go/game_state.cljc","^G",29,"^O",["^I",[["^K"]]],"^P",null,"^Q",["^I",[null,null]],"^E",1,"^R",false,"^D",61,"^S",["^6",["^Y","^T"]],"^F",61,"^U",1,"^V",true,"^H",["^I",["^J",["^I",[["^K"]]]]],"^M","Get the previous state along this branch."],"~$get-current-board",["^ ","^A",null,"^B",["^ ","^C","/home/chad/Code/clojure/go/src/go/game_state.cljc","^D",41,"^E",7,"^F",41,"^G",24,"^H",["^I",["^J",["^I",[["^K"]]]]],"^M","Return the current gameboard from the game history."],"^7","~$go.game-state/get-current-board","^C","src/go/game_state.cljc","^G",24,"^O",["^I",[["^K"]]],"^P",null,"^Q",["^I",[null,null]],"^E",1,"^R",false,"^D",41,"^S","^T","^F",41,"^U",1,"^V",true,"^H",["^I",["^J",["^I",[["^K"]]]]],"^M","Return the current gameboard from the game history."],"~$find-move-if-next",["^ ","^A",null,"^B",["^ ","^C","/home/chad/Code/clojure/go/src/go/game_state.cljc","^D",140,"^E",7,"^F",140,"^G",24,"^H",["^I",["^J",["^I",[["^K","^["]]]]],"^M","Find the position of the given move, if it's the next move in the branch (or its children)."],"^7","~$go.game-state/find-move-if-next","^C","src/go/game_state.cljc","^G",24,"^O",["^I",[["^K","^["]]],"^P",null,"^Q",["^I",[null,null]],"^E",1,"^R",false,"^D",140,"^S",["^6",[null,"^Y","^T","~$clj-nil"]],"^F",140,"^U",2,"^V",true,"^H",["^I",["^J",["^I",[["^K","^["]]]]],"^M","Find the position of the given move, if it's the next move in the branch (or its children)."],"~$move-down-parallel-branch",["^ ","^A",null,"^B",["^ ","^C","/home/chad/Code/clojure/go/src/go/game_state.cljc","^D",130,"^E",7,"^F",130,"^G",32,"^H",["^I",["^J",["^I",[["^K"]]]]],"^M","Move down to the next sibling branch."],"^7","~$go.game-state/move-down-parallel-branch","^C","src/go/game_state.cljc","^G",32,"^O",["^I",[["^K"]]],"^P",null,"^Q",["^I",[null,null]],"^E",1,"^R",false,"^D",130,"^S",["^6",["^Y","^T"]],"^F",130,"^U",1,"^V",true,"^H",["^I",["^J",["^I",[["^K"]]]]],"^M","Move down to the next sibling branch."],"~$advance-if-next-move",["^ ","^A",null,"^B",["^ ","^C","/home/chad/Code/clojure/go/src/go/game_state.cljc","^D",151,"^E",7,"^F",151,"^G",27,"^H",["^I",["^J",["^I",[["^K","^["]]]]],"^M","If the given move is the next move in the branch (or its children), advance to it."],"^7","~$go.game-state/advance-if-next-move","^C","src/go/game_state.cljc","^G",27,"^O",["^I",[["^K","^["]]],"^P",null,"^Q",["^I",[null,null]],"^E",1,"^R",false,"^D",151,"^S",["^6",["^Y","^T","^1N"]],"^F",151,"^U",2,"^V",true,"^H",["^I",["^J",["^I",[["^K","^["]]]]],"^M","If the given move is the next move in the branch (or its children), advance to it."],"~$get-empty-board",["^ ","^A",null,"^B",["^ ","^C","/home/chad/Code/clojure/go/src/go/game_state.cljc","^D",15,"^E",7,"^F",15,"^G",22,"^H",["^I",["^J",["^I",[["^1;"]]]]],"^M","Return a new empty game board"],"^7","~$go.game-state/get-empty-board","^C","src/go/game_state.cljc","^G",22,"^O",["^I",[["^1;"]]],"^P",null,"^Q",["^I",[null,null]],"^E",1,"^R",false,"^D",15,"^S",["^6",["^Y","~$cljs.core/IVector","^T","~$cljs.core/MetaFn","^1N"]],"^F",15,"^U",1,"^V",true,"^H",["^I",["^J",["^I",[["^1;"]]]]],"^M","Return a new empty game board"],"~$get-last-move",["^ ","^A",null,"^B",["^ ","^C","/home/chad/Code/clojure/go/src/go/game_state.cljc","^D",46,"^E",7,"^F",46,"^G",20,"^H",["^I",["^J",["^I",[["^K"]]]]],"^M","Return the last move from the current path."],"^7","~$go.game-state/get-last-move","^C","src/go/game_state.cljc","^G",20,"^O",["^I",[["^K"]]],"^P",null,"^Q",["^I",[null,null]],"^E",1,"^R",false,"^D",46,"^S","^T","^F",46,"^U",1,"^V",true,"^H",["^I",["^J",["^I",[["^K"]]]]],"^M","Return the last move from the current path."]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^6",["~:last-move","~:else","~:history","~:position","~:board"]],"~:order",["^23","^24","^25","^21","^22"]],"^M",null]